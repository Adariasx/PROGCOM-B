# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1az78veO1Jc1TLYpKxELFDurkusIRFXZH
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp

# --------------------------
# FunciÃ³n de simulaciÃ³n RLC
# --------------------------
def simular_RLC(R, L, C, V0, t_final=1.0):
    # Fuente escalÃ³n de V0
    def V_in(t):
        return V0 if t >= 0 else 0

    # Ecuaciones diferenciales
    # y[0] = i(t), y[1] = di/dt
    def circuito(t, y):
        i, di = y
        d2i = ((0 - R*di - (1/C)*i)) / L  # dV/dt = 0 porque V(t) es constante
        return [di, d2i]

    # Condiciones iniciales
    y0 = [0.0, 0.0]

    # Tiempo de simulaciÃ³n
    t_span = (0, t_final)
    t_eval = np.linspace(t_span[0], t_span[1], 1000)

    # Resolver
    sol = solve_ivp(circuito, t_span, y0, t_eval=t_eval)
    return sol.t, sol.y

# --------------------------
# Programa interactivo
# --------------------------
if __name__ == "__main__":
    print("ðŸ“¡ SimulaciÃ³n de circuito RLC en serie ðŸ“¡")
    R = float(input("Ingrese R [Ohm]: "))
    L = float(input("Ingrese L [H]: "))
    C = float(input("Ingrese C [F]: "))
    V0 = float(input("Ingrese voltaje de entrada (escalÃ³n) [V]: "))
    t_final = float(input("Ingrese tiempo final de simulaciÃ³n [s]: "))

    # Simular
    t, y = simular_RLC(R, L, C, V0, t_final)

    # Calcular factor de amortiguamiento
    alpha = R / (2*L)
    omega0 = 1 / np.sqrt(L*C)
    if alpha < omega0:
        tipo = "Subamortiguado (oscilatorio)"
    elif np.isclose(alpha, omega0):
        tipo = "CrÃ­ticamente amortiguado"
    else:
        tipo = "Sobreamortiguado"

    print(f"\nâš¡ Tipo de respuesta: {tipo}")

    # Graficar
    plt.figure(figsize=(10,5))
    plt.plot(t, y[0], label="Corriente i(t) [A]", color="b")
    plt.plot(t, y[1], label="di/dt [A/s]", color="r", linestyle="--")
    plt.title(f"Respuesta del circuito RLC ({tipo})")
    plt.xlabel("Tiempo [s]")
    plt.ylabel("Magnitud")
    plt.grid(True)
    plt.legend()
    plt.show()